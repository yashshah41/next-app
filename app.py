from flask import Flask, request
from random import randint
from flask_cors import CORS, cross_origin
from collections import Counter
from datetime import datetime, timedelta
import spotifyrec
from apscheduler.schedulers.background import BackgroundScheduler
from collections import Counter
import atexit

# every N seconds checks if there are expired voting polls and deletes them so the main thread can populate with new songs
def checker_thread():
    print()
    print(room_songs)
    for key in room_songs.keys():
        print(key in room_songs)
        if key in room_songs and 'timestamp' in room_songs[key] and room_songs[key]['timestamp'] < datetime.now():
            room_votes_freq = Counter()

            best_track = max(room_votes, key=room_votes_freq.get)
            print(f"best_track {best_track}")
            print(f"playlist id {room_to_playlist_id[key]}")
            spotifyrec.add_track_to_playlist(
                room_to_playlist_id[key], best_track)
            spotifyrec.enqueue(uri=best_track)

            room_songs[key] = []
            room_votes[key] = []

            print(best_track, 'best_track')
    print('removed')


sched = BackgroundScheduler(daemon=True)
sched.add_job(checker_thread, 'interval', seconds=10)
sched.start()


def shutdown_scheduler():
    sched.shutdown()


app = Flask(__name__)
CORS(app) #required because browser was having trouble

# This one keeps the list of songs on a room rn
room_songs = {}
# this one includes the room's votes for a specific song
room_votes = {}
room_to_playlist_id = {}

SONG_AMOUNT = 5  # length of song
KEY_LENGTH = 5 # length of key generated by makeroom

# takes a uri that one individual votes on as the best
#given more time this would rank N songs best to worst for Ranked Choice voting (or a different algo)
@app.route('/vote', methods=['POST'])
def add_to_dict():
    key = request.json['key']
    vote = request.json['uri']

    if key.isdigit() and len(key) == KEY_LENGTH:
        if key in room_votes:
            print(vote)
            room_votes[key].append(vote)
            return {"nothing": 'Successful'}
        else:
            return {"error": 'Bad request'}
    else:
        return {'error': 'Invalid key format'}

#makes a new room 
# creates a playlist in spotify
@app.route('/make_room', methods=['GET'])
def make_room():
    while True:
        random_number = str(randint(10000, 99999))
        if random_number not in room_votes.keys() and random_number not in room_songs.keys():
            room_votes[random_number] = []
            room_songs[random_number] = []
            break
    print(room_votes)

    room_to_playlist_id[random_number] = spotifyrec.make_playlist()

    return {'room': random_number}


@app.route('/rooms', methods=['GET'])
def rooms():
    return [room_votes, room_songs]

# sends a list of songs for that room
# if the timer has not expired then send the same list, otherwise send a new one
# given more time we would have made the timer change per the length of the song but decided on making it 100s for dev
# when recommendations was working we would pass in the previous winner to add more context and overtime understand what the room was looking for and tailor to it

@app.route('/song_list', methods=['POST', 'OPTIONS'])
@cross_origin()
def song_list():
    key = request.json['key']
    print(key)

    if key in room_songs and 'timestamp' in room_songs[key] and room_songs[key]['timestamp'] > datetime.now():
        return room_songs[key]
    elif key in room_songs:
        room_songs[key] = {'songs': spotifyrec.recommendations(),
                           'timestamp': datetime.now() + timedelta(seconds=100)}
        return room_songs[key]
    else:
        return {'error': '0'}

#the scheduler deletes the song voting in rooms that timers have expired so that we can create new polls
if __name__ == '__main__':
    app.run(debug=True)
    atexit.register(shutdown_scheduler)
